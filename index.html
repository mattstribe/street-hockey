<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>8‑Bit Street Hockey</title>
  <meta name="description" content="A retro 8‑bit street hockey shootout. Move with WASD/Arrows, shoot with Space." />
  <meta property="og:title" content="8‑Bit Street Hockey" />
  <meta property="og:description" content="A retro 8‑bit street hockey shootout." />
  <style>
    :root { --scale: 1; --w: 240; --h: 600; }
    html, body { height: 100%; margin: 0; background:#0f172a; color:#e5e7eb; font-family: system-ui, sans-serif; }
    .wrap { display:grid; place-items:center; gap:12px; height:100%; padding:12px; }
    canvas { width: calc(var(--w) * var(--scale) * 1px); height: calc(var(--h) * var(--scale) * 1px); image-rendering: pixelated; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.45); }
    .hud { display:flex; flex-wrap:wrap; gap:12px; align-items:center; font-size:14px; opacity:.95; justify-content:center; }
    .btn { background:#1f2937; border:1px solid #374151; padding:6px 10px; border-radius:8px; color:#e5e7eb; cursor:pointer; }
    .btn:hover { background:#111827; }
    .kbd { background:#111827; border:1px solid #374151; padding:2px 6px; border-radius:6px; font-family: ui-monospace; }
    .badge { padding:2px 6px; border-radius:6px; background:#0b1220; border:1px solid #243047; font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="240" height="600"></canvas>
    <div class="hud">
      <div><strong>Time:</strong> <span id="time">60.0</span>s</div>
      <div><strong>Score:</strong> <span id="score">0</span></div>
      <div><strong>Shots:</strong> <span id="shots">0</span></div>
      <div class="badge" id="spriteStatus">Sprites: loading…</div>
      <div class="badge" id="geomStatus">Rink: testing…</div>
      <div class="badge" id="testsStatus">Tests: running…</div>
      <button class="btn" id="reset"><span>Reset (</span><span class="kbd">R</span>)</button>
      <div style="opacity:.8">Move: <span class="kbd">WASD</span>/<span class="kbd">Arrows</span> • Shoot: <span class="kbd">Space</span></div>
    </div>
  </div>

  <script>
  // 8‑Bit Street Hockey — embedded (base64) sprites, no external files
  (() => {
    const W = 240, H = 600; // 2:5 aspect for 80x200 ft rink
    const FEET_W = 80, FEET_H = 200;
    const MARGIN = 8;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const ui = {
      time: document.getElementById('time'),
      score: document.getElementById('score'),
      shots: document.getElementById('shots'),
      reset: document.getElementById('reset'),
      spriteStatus: document.getElementById('spriteStatus'),
      geomStatus: document.getElementById('geomStatus'),
      testsStatus: document.getElementById('testsStatus'),
    };

    // --- scale feet→px and rink geometry ---
    const scale = Math.min((W - 2*MARGIN) / FEET_W, (H - 2*MARGIN) / FEET_H);
    const rink = {
      x: Math.round((W - FEET_W * scale) / 2),
      y: Math.round((H - FEET_H * scale) / 2),
      w: Math.round(FEET_W * scale),
      h: Math.round(FEET_H * scale)
    };

    const GOAL_W_FT = 6, GOAL_DEPTH_FT = 2, CREASE_RADIUS_FT = 6;
    const goalTop = { w: Math.round(GOAL_W_FT * scale) };
    goalTop.h = Math.max(4, Math.round(GOAL_DEPTH_FT * scale));
    goalTop.x = Math.round(W/2 - goalTop.w/2);
    goalTop.y = rink.y + 2;
    const goalBot = { w: goalTop.w, h: goalTop.h, x: goalTop.x, y: rink.y + rink.h - goalTop.h - 2 };

    // --- Entities ---
    const player = { x: W/2, y: rink.y + rink.h - 24, speed: 85, anim: 0, animTimer: 0 };
    const goalie = { x: W/2, y: goalTop.y + goalTop.h + 12, vx: 40, anim: 0, animTimer: 0 };
    const puck = { x: player.x, y: player.y - 10, r: 2, vx: 0, vy: 0, max: 150, sticked: true };

    // --- Pixel maps → data URL sprites ---
    // '.'=transparent, palette below
    const playerFrames = [
      ["....kkk.....","...kkkkk....","...kfffk....","...kkkkk....","..bbbbbbb...","..bbbbbbb.s.","..bbbbbbbss.","...bbbbb.s..","...bbbbb....","..bb...bb...","..b.....b...","..s.....s..."],
      ["....kkk.....","...kkkkk....","...kfffk....","...kkkkk....","..bbbbbbb...","..bbbbbbb.s.","..bbbbbbbss.","...bbbbb.s..","..bbbbb.....","..b..b..b...","..b.....b...","..s.....s..."]
    ];
    const goalieFrames = [
      ["....KKKK....","...KfffK....","....KKKK....","..YYYYYYY...","..YYYYYYY...","..YyyyyyY...","..YyyyyyY...","..YYYYYYY...","...Y...Y....","...Y...Y....","....YYY.....",".....Y......"],
      ["....KKKK....","...KfffK....","....KKKK....","..YYYYYYY...","..YYYYYYY...","..YyYYYyY...","..YyYYYyY...","..YYYYYYY...","...Y...Y....","...Y...Y....","....YYY.....",".....Y......"]
    ];
    const palette = { k:'#0ea5e9', f:'#f4c38a', b:'#22d3ee', s:'#8b5a2b', K:'#1f2937', Y:'#fbbf24', y:'#d97706', '.':null };

    function makeDataURL(map){
      const h = map.length, w = Math.max(...map.map(r=>r.length));
      const off = document.createElement('canvas'); off.width = w; off.height = h;
      const c = off.getContext('2d'); c.imageSmoothingEnabled = false;
      for (let j=0;j<h;j++){
        const row = map[j];
        for (let i=0;i<row.length;i++){
          const col = palette[row[i]||'.']; if(!col) continue; c.fillStyle = col; c.fillRect(i,j,1,1);
        }
      }
      return off.toDataURL('image/png');
    }

    const images = { player: [new Image(), new Image()], goalie: [new Image(), new Image()] };
    images.player[0].src = makeDataURL(playerFrames[0]);
    images.player[1].src = makeDataURL(playerFrames[1]);
    images.goalie[0].src = makeDataURL(goalieFrames[0]);
    images.goalie[1].src = makeDataURL(goalieFrames[1]);

    let spritesReady = 0;
    const totalSprites = 4;
    function onSprite(){ spritesReady++; if (spritesReady === totalSprites){ markSpritesOK(); } }
    images.player[0].onload = onSprite; images.player[1].onload = onSprite; images.goalie[0].onload = onSprite; images.goalie[1].onload = onSprite;
    images.player[0].onerror = images.player[1].onerror = images.goalie[0].onerror = images.goalie[1].onerror = () => markSpritesFail();

    function markSpritesOK(){ ui.spriteStatus.textContent = 'Sprites: OK'; ui.spriteStatus.style.borderColor = '#14532d'; ui.spriteStatus.style.background = '#052e27'; }
    function markSpritesFail(){ ui.spriteStatus.textContent = 'Sprites: FAILED'; ui.spriteStatus.style.borderColor = '#7c2d12'; ui.spriteStatus.style.background = '#3b0a0a'; }

    // --- Input ---
    const keys = new Set();
    window.addEventListener('keydown', e => { keys.add(e.key); if (e.key === ' ') e.preventDefault(); });
    window.addEventListener('keyup', e => keys.delete(e.key));
    window.addEventListener('blur', ()=> keys.clear());
    ui.reset.addEventListener('click', reset);

    // --- Game state ---
    let last = performance.now();
    let playing = true; let timeLeft = 60.0; let score = 0; let shots = 0;

    function reset(){
      timeLeft = 60.0; score = 0; shots = 0; playing = true;
      player.x = W/2; player.y = rink.y + rink.h - 20; player.anim = 0; player.animTimer = 0;
      goalie.x = W/2; goalie.vx = 40; goalie.anim = 0; goalie.animTimer = 0;
      resetPuck(true); updateHUD();
    }
    function resetPuck(stick=false){ puck.x = player.x; puck.y = player.y - 10; puck.vx = 0; puck.vy = 0; puck.sticked = !!stick; }
    function shoot(){
      if (!puck.sticked) return;
      let ax=0, ay=-1; if (keys.has('ArrowLeft')||keys.has('a')) ax-=.6; if (keys.has('ArrowRight')||keys.has('d')) ax+=.6; if (keys.has('ArrowUp')||keys.has('w')) ay-=.2;
      const len = Math.hypot(ax,ay)||1, speed = puck.max; puck.vx=(ax/len)*speed; puck.vy=(ay/len)*speed; puck.sticked=false; shots++; updateHUD();
    }
    window.addEventListener('keydown', e=>{ if(e.key===' ') shoot(); if(e.key==='r'||e.key==='R') reset(); });

    function update(dt){
      if (!playing) return; timeLeft-=dt; if (timeLeft<=0){ timeLeft=0; playing=false; }
      // movement & anim
      let dx=0,dy=0, moving=false; if(keys.has('ArrowLeft')||keys.has('a')){dx-=1;moving=true} if(keys.has('ArrowRight')||keys.has('d')){dx+=1;moving=true} if(keys.has('ArrowUp')||keys.has('w')){dy-=1;moving=true} if(keys.has('ArrowDown')||keys.has('s')){dy+=1;moving=true}
      const m=Math.hypot(dx,dy)||1; player.x+=dx/m*player.speed*dt; player.y+=dy/m*player.speed*dt; if(moving){player.animTimer+=dt; if(player.animTimer>0.18){player.anim=1-player.anim; player.animTimer=0;}}
      // clamp
      const pm=6; player.x=Math.max(rink.x+pm,Math.min(rink.x+rink.w-pm,player.x)); player.y=Math.max(rink.y+goalTop.h+12,Math.min(rink.y+rink.h-goalBot.h-6,player.y));
      // puck
      if(puck.sticked){puck.x=player.x; puck.y=player.y-10;} else {puck.x+=puck.vx*dt; puck.y+=puck.vy*dt; puck.vx*=(1-1.2*dt); puck.vy*=(1-1.2*dt); if(Math.hypot(puck.vx,puck.vy)<8){puck.vx=0;puck.vy=0;}}
      // walls
      if(puck.x-puck.r<rink.x){puck.x=rink.x+puck.r;puck.vx=Math.abs(puck.vx)} if(puck.x+puck.r>rink.x+rink.w){puck.x=rink.x+rink.w-puck.r;puck.vx=-Math.abs(puck.vx)}
      if(puck.y-puck.r<rink.y){ if(!(puck.x>=goalTop.x&&puck.x<=goalTop.x+goalTop.w)){puck.y=rink.y+puck.r;puck.vy=Math.abs(puck.vy)} }
      if(puck.y+puck.r>rink.y+rink.h){ if(!(puck.x>=goalBot.x&&puck.x<=goalBot.x+goalBot.w)){puck.y=rink.y+rink.h-puck.r;puck.vy=-Math.abs(puck.vy)} }
      // bounce off player
      if(!puck.sticked && rectCircle(player.x-4, player.y-6, 8, 12, puck.x, puck.y, puck.r)){
        const nx=(puck.x-player.x)||0.0001, ny=(puck.y-player.y)||0.0001, L=Math.hypot(nx,ny), ux=nx/L, uy=ny/L; const sp=Math.min(puck.max, Math.hypot(puck.vx,puck.vy)*1.05+30); puck.vx=ux*sp; puck.vy=uy*sp-30;
      }
      // goalie patrol
      goalie.x += goalie.vx*dt; goalie.animTimer+=dt; if(goalie.animTimer>0.22){goalie.anim=1-goalie.anim; goalie.animTimer=0}
      const Lm = goalTop.x, Rm = goalTop.x + goalTop.w; // patrol within mouth
      if(goalie.x < Lm){goalie.x = Lm; goalie.vx *= -1}
      if(goalie.x > Rm){goalie.x = Rm; goalie.vx *= -1}
      // goalie collision
      if(!puck.sticked && rectCircle(goalie.x-6, goalie.y-5, 12, 10, puck.x, puck.y, puck.r)){
        puck.vy=Math.abs(puck.vy)+30; if(puck.x<goalie.x) puck.vx=-Math.abs(puck.vx); if(puck.x>goalie.x) puck.vx=Math.abs(puck.vx);
      }
      // goal (top)
      if(!puck.sticked && puck.y-puck.r<=goalTop.y+goalTop.h && puck.x>=goalTop.x && puck.x<=goalTop.x+goalTop.w){ score++; resetPuck(true); updateHUD(); }
      // reclaim slow puck
      if(!puck.sticked && Math.hypot(puck.vx,puck.vy)<5 && rectCircle(player.x-4,player.y-6,8,12,puck.x,puck.y,puck.r)) puck.sticked=true;
      updateHUD();
    }

    function updateHUD(){ ui.time.textContent=timeLeft.toFixed(1); ui.score.textContent=String(score); ui.shots.textContent=String(shots); }

    function draw(){
      ctx.fillStyle='#111827'; ctx.fillRect(0,0,W,H);
      // rink / lines
      fillRect(rink.x, rink.y, rink.w, rink.h, '#0b1220'); strokeRect(rink.x, rink.y, rink.w, rink.h, '#334155');
      drawSolidLine(rink.x+2, Math.round(rink.y+rink.h/2), rink.x+rink.w-2, Math.round(rink.y+rink.h/2), '#c2410c');
      drawCirclePx(W/2, Math.round(rink.y + rink.h*0.25), 12, '#1f2a44');
      drawCirclePx(W/2, Math.round(rink.y + rink.h*0.75), 12, '#1f2a44');
      // goals + crease
      fillRect(goalTop.x, goalTop.y, goalTop.w, goalTop.h, '#182235'); strokeRect(goalTop.x, goalTop.y, goalTop.w, goalTop.h, '#64748b');
      fillRect(goalBot.x, goalBot.y, goalBot.w, goalBot.h, '#182235'); strokeRect(goalBot.x, goalBot.y, goalBot.w, goalBot.h, '#64748b');
      drawCrease(goalTop.x+goalTop.w/2, goalTop.y+goalTop.h, Math.round(CREASE_RADIUS_FT*scale), 'top');
      drawCrease(goalBot.x+goalBot.w/2, goalBot.y, Math.round(CREASE_RADIUS_FT*scale), 'bottom');
      // sprites (16x16)
      const ps = images.player[player.anim], gs = images.goalie[goalie.anim];
      if (ps && ps.complete) ctx.drawImage(ps, Math.round(player.x-8), Math.round(player.y-8), 16, 16);
      if (gs && gs.complete) ctx.drawImage(gs, Math.round(goalie.x-8), Math.round(goalie.y-8), 16, 16);
      // ball
      drawBall(puck.x, puck.y, puck.r);
      if (!playing) drawOverlay();
    }

    function loop(now){ const dt=Math.min(0.033,(now-last)/1000); last=now; update(dt); draw(); requestAnimationFrame(loop); }

    // --- helpers ---
    function fillRect(x,y,w,h,color){ ctx.fillStyle=color; ctx.fillRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h)); }
    function strokeRect(x,y,w,h,color){ ctx.strokeStyle=color; ctx.lineWidth=1; ctx.strokeRect(Math.round(x)+.5,Math.round(y)+.5,Math.round(w),Math.round(h)); }
    function drawSolidLine(x1,y,x2,y2,color){ ctx.strokeStyle=color; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(Math.round(x1)+.5, Math.round(y)+.5); ctx.lineTo(Math.round(x2)+.5, Math.round(y2)+.5); ctx.stroke(); }
    function drawCirclePx(x,y,r,color){ ctx.strokeStyle=color; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(Math.round(x)+.5, Math.round(y)+.5, r, 0, Math.PI*2); ctx.stroke(); }
    function drawBall(x,y,r){ const X=Math.round(x),Y=Math.round(y); ctx.fillStyle='#f97316'; ctx.beginPath(); ctx.arc(X,Y,r+2,0,Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.beginPath(); ctx.arc(X-1,Y-1,r-1,0,Math.PI*2); ctx.fill(); }
    function rectCircle(rx,ry,rw,rh,cx,cy,cr){ const closestX=Math.max(rx,Math.min(cx,rx+rw)); const closestY=Math.max(ry,Math.min(cy,ry+rh)); const dx=cx-closestX, dy=cy-closestY; return dx*dx+dy*dy <= cr*cr; }
    function drawOverlay(){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#e5e7eb'; ctx.textAlign='center'; ctx.font='10px monospace'; ctx.fillText("Time's up!", W/2, H/2-12); ctx.fillText(`Score: ${score}   Shots: ${shots}`, W/2, H/2+2); ctx.fillText('Press R to restart', W/2, H/2+16); }

    // ✅ FIX: define drawCrease that was previously missing
    function drawCrease(cx, cy, r, side){
      ctx.strokeStyle = '#475569';
      ctx.lineWidth = 1;
      ctx.beginPath();
      if (side === 'top'){
        ctx.arc(Math.round(cx)+.5, Math.round(cy)+.5, r, 0, Math.PI, true);
      } else {
        ctx.arc(Math.round(cx)+.5, Math.round(cy)+.5, r, 0, Math.PI, false);
      }
      ctx.stroke();
    }

    // --- tests ---
    (function runGeometryTests(){
      const aspect=rink.w/rink.h, expected=FEET_W/FEET_H; const ok=Math.abs(aspect-expected)<0.02;
      ui.geomStatus.textContent = ok?`Rink: OK (${aspect.toFixed(3)}~${expected.toFixed(3)})`:`Rink: BAD (${aspect.toFixed(3)} vs ${expected.toFixed(3)})`;
      ui.geomStatus.style.borderColor = ok?'#14532d':'#7c2d12'; ui.geomStatus.style.background = ok?'#052e27':'#3b0a0a';
    })();

    // New tests: ensure drawCrease renders for both top/bottom and function exists
    (function runCreaseTests(){
      try {
        const off = document.createElement('canvas'); off.width = 64; off.height = 64; const c = off.getContext('2d');
        function drawCreaseTo(ctx2,cx,cy,r,side){ ctx2.strokeStyle='#000'; ctx2.lineWidth=1; ctx2.beginPath(); if(side==='top'){ ctx2.arc(cx+.5,cy+.5,r,0,Math.PI,true);} else { ctx2.arc(cx+.5,cy+.5,r,0,Math.PI,false);} ctx2.stroke(); }
        drawCreaseTo(c, 32, 20, 12, 'top');
        drawCreaseTo(c, 32, 44, 12, 'bottom');
        const data = c.getImageData(0,0,64,64).data; let ink=0; for(let i=3;i<data.length;i+=4){ if(data[i]>0){ ink=1; break; } }
        const exists = (typeof drawCrease === 'function');
        const passed = exists && ink>0;
        ui.testsStatus.textContent = passed ? 'Tests: OK' : 'Tests: FAILED';
        ui.testsStatus.style.borderColor = passed ? '#14532d' : '#7c2d12';
        ui.testsStatus.style.background = passed ? '#052e27' : '#3b0a0a';
      } catch(err){
        ui.testsStatus.textContent = 'Tests: ERROR';
        ui.testsStatus.style.borderColor = '#7c2d12';
        ui.testsStatus.style.background = '#3b0a0a';
        console.error('Test error:', err);
      }
    })();

    // boot
    reset(); requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
